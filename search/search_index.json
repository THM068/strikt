{
    "docs": [
        {
            "location": "/", 
            "text": "Strikt is an assertion library for Kotlin intended for use with a test runner such as \nJUnit\n or \nSpek\n.\nIt's very much inspired by \nAssertJ\n, \nAtrium\n and \nHamkrest\n.\nHowever, none of those provided exactly what I wanted so I decided to create my own assertions library.\n\n\nThe design goals I had in mind were:\n\n\n\n\nAn assertion API that takes advantage of Kotlin's strong type system.\n\n\nEasy \"soft assertions\" out of the box.\n\n\nA simple API for composing custom assertions.\n\n\nLegible syntax that an IDE can help with.\n\n\nUse Kotlin's nice language features without getting overly-clever (torturing everything into an infix function syntax, or trying to recreate \nSpock\n's assertion syntax in a language that can't really do it, for example).\n\n\nA rich selection of assertions that apply to common types without a tangled hierarchy of classes and self-referential generic types, (it turns out Kotlin's extension functions make this pretty easy to accomplish).\n\n\nSimple setup -- one dependency, one (okay, two) imports and you're up and running.\n\n\n\n\nInstallation\n\n\nStrikt is available from JCenter.\nAdd the following to your \nbuild.gradle\n.\n\n\nrepositories { \n  jcenter() \n}\n\ndependencies {\n  testCompile \nio.github.robfletcher.strikt:strikt-core:0.3.0\n\n}", 
            "title": "Home"
        }, 
        {
            "location": "/#installation", 
            "text": "Strikt is available from JCenter.\nAdd the following to your  build.gradle .  repositories { \n  jcenter() \n}\n\ndependencies {\n  testCompile  io.github.robfletcher.strikt:strikt-core:0.3.0 \n}", 
            "title": "Installation"
        }, 
        {
            "location": "/user-guide/using-strikt/", 
            "text": "Using Strikt\n\n\nStrikt does not depend on any particular test runner.\nIt can be used with JUnit, Spek or any other runner that supports tests written in Kotlin.\n\n\nAssertion styles\n\n\nTwo different styles of assertion -- chained and block -- are supported for different use-cases.\nYou can mix and match both in the same test and even nest chained assertions inside block assertions.\n\n\nChained assertions\n\n\nChained assertions use a fluent API.\nThey fail fast.\nThat is, the first assertion that fails breaks the chain and further assertions are not evaluated.\n\n\nEach assertion in the chain returns an \nAssertion\n object that supports further assertions.\n\n\nval subject = \ncovfefe\n\nexpect(subject)\n  .isA\nString\n()\n  .hasLength(1)\n  .isUpperCase()\n\n\n\n\nProduces the output: \n\n\n\u25bc Expect that \ncovfefe\n\n  \u2714 is a java.lang.String\n  \u2718 has length 1\n    \u21b3 found 7\n\n\n\n\nNotice that the \nisUpperCase()\n assertion is not applied as the earlier \nhasLength(1)\n assertion failed.\n\n\nBlock assertions\n\n\nBlock assertions are declared in a block whose receiver is an assertion on a target object.\nBlock assertions do \nnot\n fail fast.\nThat is, all assertions in the block are evaluated and the result of the \"compound\" assertion will include results for all the assertions made in the block.\n\n\nval subject = \ncovfefe\n\nexpect(subject) {\n  isA\nString\n()\n  hasLength(1)\n  isUpperCase()\n}\n\n\n\n\nProduces the output:\n\n\n\u25bc Expect that \ncovfefe\n\n  \u2714 is a java.lang.String\n  \u2718 has length 1\n    \u21b3 found 7\n  \u2718 is upper case\n\n\n\n\nAll assertions are applied and since two fail there are two errors logged.\n\n\nChained assertions inside block assertions\n\n\nChained assertions inside a block \nwill\n still fail fast but will not prevent other assertions in the block from being evaluated.\n\n\nval subject = 1L\nexpect(subject) {\n  lessThan(1).isA\nInt\n()\n  greaterThan(1)\n}\n\n\n\n\nProduces the output:\n\n\n\u25bc Expect that 1\n  \u2718 is less than 1\n  \u2718 is greater than 1\n\n\n\n\nNote the \nisA\nInt\n assertion (that would have failed) was not evaluated since it was chained after \nlessThan(1)\n which failed.\nThe \ngreaterThan(1)\n assertion \nwas\n evaluated since it was not part of the same chain.\n\n\nFlow typed assertions\n\n\nChained assertions return an \nAssertion\nT\n object with a generic type representing the (declared) type of the assertion subject.\nSome assertions will return a \ndifferent\n type to the one they were called on.\nFor example, if the subject of an assertion is a nullable type (in other words it's an \nAssertion\nT?\n) the assertion methods \nisNull()\n and \nisNotNull()\n are available.\nThe return type of \nisNotNull()\n is \nAssertion\nT\n because we now \nknow\n the subject is not null.\nYou will find IDE code-completion will no longer offer the \nisNull()\n and \nisNotNull()\n assertion methods.\n\n\nAnother example comes when testing values with broad types and making assertions about their specific runtime type.\nFor example:\n\n\nval subject: Map\nString, Any\n = mapOf(\ncount\n to 1, \nname\n to \nRob\n)\nexpect(subject.get(\ncount\n)).isA\nNumber\n().isGreaterThan(0)\nexpect(subject.get(\nname\n)).isA\nString\n().hasLength(3)\n\n\n\n\nThe return type of the subject map's \nget()\n method is \nAny\n but using the \"down-cast\" assertion \nisA\nT\n()\n we can both assert the type of the value and -- because the compiler now knows it is dealing with an \nAssertion\nString\n or an \nAssertion\nNumber\n -- we can use more specialized assertion methods that are only available for those subject types.\n\n\nWithout the \nisA\nT\n()\n assertion the code would not compile:\n\n\nval subject: Map\nString, Any\n = mapOf(\ncount\n to 1, \nname\n to \nRob\n)\nexpect(subject.get(\ncount\n)).isGreaterThan(0) // isGreaterThan does not exist on Assertion\nAny\n\nexpect(subject.get(\nname\n)).hasLength(3) // hasLength does not exist on Assertion\nAny\n\n\n\n\n\nThis mechanism means that IDE code-completion is optimally helpful as only assertion methods that are appropriate to the subject type will be suggested. \n\n\nAssertions on elements of a collection\n\n\nSome assertions on collections include sub-assertions applied to the elements of the collection.\nFor example, we can assert that \nall\n elements conform to a repeated assertion.\n\n\nval subject = setOf(\ncatflap\n, \nrubberplant\n, \nmarzipan\n)\nexpect(subject).all {\n  isLowerCase()\n  startsWith('c')\n}\n\n\n\n\nProduces the output:\n\n\n\u25bc Expect that [catflap, rubberplant, marzipan] \n  \u2718 all elements match:\n    \u25bc \ncatflap\n\n      \u2714 starts with 'c'\n      \u2714 is lower case\n    \u25bc \nrubberplant\n \n      \u2718 starts with 'c'\n      \u2714 is lower case\n    \u25bc \nmarzipan\n\n      \u2718 starts with 'c'\n      \u2714 is lower case\n\n\n\n\nThe results are broken down by individual elements in the collection so it's easy to see which failed.\n\n\nAsserting exceptions are thrown\n\n\nTo assert that some code throws an exception you can use the \nthrows\nE\n function.\nFor example:\n\n\nthrows\nTooMuchFlaxException\n {\n  service.computeMeaning()\n}\n\n\n\n\nThe \nthrows\nE\n function returns an \nAssertion\nE\n so you can chain assertions about the exception after it.\n\n\nMapping assertions using lambdas\n\n\nIn order to map the assertion chain to a property or method result of the current subject you can use the \nmap\n method.\nThe method takes a lambda whose receiver is the current subject and returns an \nAssertion\nR\n where \nR\n is whatever the lambda returns.\n\n\nThis is sometimes useful for making assertions about the properties of an object or the values returned by methods.\n\n\nval subject = Person(name = \nDavid\n, birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  map { name }.isEqualTo(\nDavid\n)\n  map { birthDate }.map { year }.isEqualTo(1947)\n}\n\n\n\n\nMapping with property or getter references\n\n\nIf you use a Kotlin property or Java getter reference as the lambda passed to \nmap\n, Strikt will automatically derive the property name and use it as the subject description on the returned assertion. \nThis is very useful for generating good quality assertion output with minimal effort.\n\n\nFor example, if the previous example fails it will format the error message like this:\n\n\n\u25bc Person[name: Ziggy, birthDate: 1972-06-16] \n  \u25bc Ziggy \n    \u2718 is equal to David\n  \u25bc 1972-06-16 \n    \u25bc 1972\n      \u2718 is equal to 1947\n\n\n\n\nHowever, using property references, the output is more useful.\n\n\nval subject = Person(name = \nDavid\n, birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  map(Person::name).isEqualTo(\nDavid\n)\n  map(Person::birthDate).map(LocalDate::getYear).isEqualTo(1947)\n}\n\n\n\n\n\u25bc Person[name: Ziggy, birthDate: 1972-06-16] \n  \u25bc .name Ziggy \n    \u2718 is equal to David\n  \u25bc .birthDate 1972-06-16\n    \u25bc .year 1972 \n      \u2718 is equal to 1947\n\n\n\n\nMapping with extension properties\n\n\nPerhaps the most useful application of \nmap\n is in defining extension properties that map an assertion on a type to an assertion on one of the properties (or method return values) of that type.\n\n\nA simple example is the standard extension property Strikt supplies for \nAssertion\nCollection\n*\n that maps to an assertion on the collection's \nsize\n.\n\n\nval \nT : Collection\n*\n Assertion\nT\n.size: Assertion\nInt\n\n  get() = map(Collection\n*\n::size)\n\n\n\n\nIt is very easy to define these kind of extension properties for testing your own types.\n\n\nFor example:\n\n\nval Assertion\nPerson\n.name: Assertion\nString\n\n  get() = map(Person::name)\n\nval Assertion\nPerson\n.dateOfBirth: Assertion\nLocalDate\n\n  get() = map(Person::dateOfBirth)\n\nval Assertion\nLocalDate\n.year: Assertion\nInt\n\n  get() = map(LocalDate::getYear)\n\n\n\n\n\nYou can then write the earlier example as:\n\n\nval subject = Person(name = \nDavid\n, birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  name.isEqualTo(\nDavid\n)\n  birthDate.year.isEqualTo(1947)\n}", 
            "title": "Using Strikt"
        }, 
        {
            "location": "/user-guide/using-strikt/#using-strikt", 
            "text": "Strikt does not depend on any particular test runner.\nIt can be used with JUnit, Spek or any other runner that supports tests written in Kotlin.", 
            "title": "Using Strikt"
        }, 
        {
            "location": "/user-guide/using-strikt/#assertion-styles", 
            "text": "Two different styles of assertion -- chained and block -- are supported for different use-cases.\nYou can mix and match both in the same test and even nest chained assertions inside block assertions.", 
            "title": "Assertion styles"
        }, 
        {
            "location": "/user-guide/using-strikt/#chained-assertions", 
            "text": "Chained assertions use a fluent API.\nThey fail fast.\nThat is, the first assertion that fails breaks the chain and further assertions are not evaluated.  Each assertion in the chain returns an  Assertion  object that supports further assertions.  val subject =  covfefe \nexpect(subject)\n  .isA String ()\n  .hasLength(1)\n  .isUpperCase()  Produces the output:   \u25bc Expect that  covfefe \n  \u2714 is a java.lang.String\n  \u2718 has length 1\n    \u21b3 found 7  Notice that the  isUpperCase()  assertion is not applied as the earlier  hasLength(1)  assertion failed.", 
            "title": "Chained assertions"
        }, 
        {
            "location": "/user-guide/using-strikt/#block-assertions", 
            "text": "Block assertions are declared in a block whose receiver is an assertion on a target object.\nBlock assertions do  not  fail fast.\nThat is, all assertions in the block are evaluated and the result of the \"compound\" assertion will include results for all the assertions made in the block.  val subject =  covfefe \nexpect(subject) {\n  isA String ()\n  hasLength(1)\n  isUpperCase()\n}  Produces the output:  \u25bc Expect that  covfefe \n  \u2714 is a java.lang.String\n  \u2718 has length 1\n    \u21b3 found 7\n  \u2718 is upper case  All assertions are applied and since two fail there are two errors logged.", 
            "title": "Block assertions"
        }, 
        {
            "location": "/user-guide/using-strikt/#chained-assertions-inside-block-assertions", 
            "text": "Chained assertions inside a block  will  still fail fast but will not prevent other assertions in the block from being evaluated.  val subject = 1L\nexpect(subject) {\n  lessThan(1).isA Int ()\n  greaterThan(1)\n}  Produces the output:  \u25bc Expect that 1\n  \u2718 is less than 1\n  \u2718 is greater than 1  Note the  isA Int  assertion (that would have failed) was not evaluated since it was chained after  lessThan(1)  which failed.\nThe  greaterThan(1)  assertion  was  evaluated since it was not part of the same chain.", 
            "title": "Chained assertions inside block assertions"
        }, 
        {
            "location": "/user-guide/using-strikt/#flow-typed-assertions", 
            "text": "Chained assertions return an  Assertion T  object with a generic type representing the (declared) type of the assertion subject.\nSome assertions will return a  different  type to the one they were called on.\nFor example, if the subject of an assertion is a nullable type (in other words it's an  Assertion T? ) the assertion methods  isNull()  and  isNotNull()  are available.\nThe return type of  isNotNull()  is  Assertion T  because we now  know  the subject is not null.\nYou will find IDE code-completion will no longer offer the  isNull()  and  isNotNull()  assertion methods.  Another example comes when testing values with broad types and making assertions about their specific runtime type.\nFor example:  val subject: Map String, Any  = mapOf( count  to 1,  name  to  Rob )\nexpect(subject.get( count )).isA Number ().isGreaterThan(0)\nexpect(subject.get( name )).isA String ().hasLength(3)  The return type of the subject map's  get()  method is  Any  but using the \"down-cast\" assertion  isA T ()  we can both assert the type of the value and -- because the compiler now knows it is dealing with an  Assertion String  or an  Assertion Number  -- we can use more specialized assertion methods that are only available for those subject types.  Without the  isA T ()  assertion the code would not compile:  val subject: Map String, Any  = mapOf( count  to 1,  name  to  Rob )\nexpect(subject.get( count )).isGreaterThan(0) // isGreaterThan does not exist on Assertion Any \nexpect(subject.get( name )).hasLength(3) // hasLength does not exist on Assertion Any   This mechanism means that IDE code-completion is optimally helpful as only assertion methods that are appropriate to the subject type will be suggested.", 
            "title": "Flow typed assertions"
        }, 
        {
            "location": "/user-guide/using-strikt/#assertions-on-elements-of-a-collection", 
            "text": "Some assertions on collections include sub-assertions applied to the elements of the collection.\nFor example, we can assert that  all  elements conform to a repeated assertion.  val subject = setOf( catflap ,  rubberplant ,  marzipan )\nexpect(subject).all {\n  isLowerCase()\n  startsWith('c')\n}  Produces the output:  \u25bc Expect that [catflap, rubberplant, marzipan] \n  \u2718 all elements match:\n    \u25bc  catflap \n      \u2714 starts with 'c'\n      \u2714 is lower case\n    \u25bc  rubberplant  \n      \u2718 starts with 'c'\n      \u2714 is lower case\n    \u25bc  marzipan \n      \u2718 starts with 'c'\n      \u2714 is lower case  The results are broken down by individual elements in the collection so it's easy to see which failed.", 
            "title": "Assertions on elements of a collection"
        }, 
        {
            "location": "/user-guide/using-strikt/#asserting-exceptions-are-thrown", 
            "text": "To assert that some code throws an exception you can use the  throws E  function.\nFor example:  throws TooMuchFlaxException  {\n  service.computeMeaning()\n}  The  throws E  function returns an  Assertion E  so you can chain assertions about the exception after it.", 
            "title": "Asserting exceptions are thrown"
        }, 
        {
            "location": "/user-guide/using-strikt/#mapping-assertions-using-lambdas", 
            "text": "In order to map the assertion chain to a property or method result of the current subject you can use the  map  method.\nThe method takes a lambda whose receiver is the current subject and returns an  Assertion R  where  R  is whatever the lambda returns.  This is sometimes useful for making assertions about the properties of an object or the values returned by methods.  val subject = Person(name =  David , birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  map { name }.isEqualTo( David )\n  map { birthDate }.map { year }.isEqualTo(1947)\n}", 
            "title": "Mapping assertions using lambdas"
        }, 
        {
            "location": "/user-guide/using-strikt/#mapping-with-property-or-getter-references", 
            "text": "If you use a Kotlin property or Java getter reference as the lambda passed to  map , Strikt will automatically derive the property name and use it as the subject description on the returned assertion. \nThis is very useful for generating good quality assertion output with minimal effort.  For example, if the previous example fails it will format the error message like this:  \u25bc Person[name: Ziggy, birthDate: 1972-06-16] \n  \u25bc Ziggy \n    \u2718 is equal to David\n  \u25bc 1972-06-16 \n    \u25bc 1972\n      \u2718 is equal to 1947  However, using property references, the output is more useful.  val subject = Person(name =  David , birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  map(Person::name).isEqualTo( David )\n  map(Person::birthDate).map(LocalDate::getYear).isEqualTo(1947)\n}  \u25bc Person[name: Ziggy, birthDate: 1972-06-16] \n  \u25bc .name Ziggy \n    \u2718 is equal to David\n  \u25bc .birthDate 1972-06-16\n    \u25bc .year 1972 \n      \u2718 is equal to 1947", 
            "title": "Mapping with property or getter references"
        }, 
        {
            "location": "/user-guide/using-strikt/#mapping-with-extension-properties", 
            "text": "Perhaps the most useful application of  map  is in defining extension properties that map an assertion on a type to an assertion on one of the properties (or method return values) of that type.  A simple example is the standard extension property Strikt supplies for  Assertion Collection *  that maps to an assertion on the collection's  size .  val  T : Collection *  Assertion T .size: Assertion Int \n  get() = map(Collection * ::size)  It is very easy to define these kind of extension properties for testing your own types.  For example:  val Assertion Person .name: Assertion String \n  get() = map(Person::name)\n\nval Assertion Person .dateOfBirth: Assertion LocalDate \n  get() = map(Person::dateOfBirth)\n\nval Assertion LocalDate .year: Assertion Int \n  get() = map(LocalDate::getYear)  You can then write the earlier example as:  val subject = Person(name =  David , birthDate = LocalDate.of(1947, 1, 8))\nexpect(subject) {\n  name.isEqualTo( David )\n  birthDate.year.isEqualTo(1947)\n}", 
            "title": "Mapping with extension properties"
        }, 
        {
            "location": "/user-guide/custom-assertions/", 
            "text": "Custom Assertions\n\n\nOne of the aims of Strikt is that implementing your own assertions is \nreally, really\n easy.\nAssertion functions are \nextension functions\n on the interface \nAssertion\nT\n.\n\n\nSimple assertions\n\n\nSimple assertions produce a single message on failure.\nThey call \nassert\n passing a lambda with the assertion logic that calls \npass()\n or \nfail()\n.\n\n\nThe standard assertions \nisNull\n, \nisEqualTo\n, \nisA\nT\n and many others are simple assertions implemented just like this.\n\n\nLet's imagine we're implementing an assertion function for \njava.time.LocalDate\n that tests if the represented date is a leap day.\n\n\nfun Assertion\nLocalDate\n.isStTibsDay(): Assertion\nLocalDate\n =\n  assert(\nis St. Tib's Day\n) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -\n pass()\n      else               -\n fail()\n    }\n  }\n\n\n\n\nBreaking this down: \n\n\n\n\nWe declare the assertion function applies only to \nAssertion\nLocalDate\n.\n\n\nNote that the function also returns \nAssertion\nLocalDate\n so we can include this assertion as part of a chain.\n\n\nWe call \nassert\n passing a description of the assertion and a lambda with the assertion logic.\n\n\nIf \nsubject\n is the value we want we call \npass()\n otherwise we call \nfail()\n\n\n\n\nIf this assertion fails it will produce a message like:\n\n\n\u25bc Expect that 2018-05-01\n  \u2718 is St. Tib's Day \n\n\n\n\nWhere do \nsubject\n, \npass()\n and \nfail()\n come from?\n\n\nThe method \nassert\n accepts a description for the assertion being made and a lambda function \nAssertionContext\nT\n.() -\n Unit\n.\nThat \nAssertionContext\nT\n receiver provides the lambda everything it needs to access the \nsubject\n of the assertion and report the result via the \npass()\n or \nfail()\n method.\n\n\nDescribing the \"actual\" value\n\n\nFor assertions that perform a comparison between actual and expected values it is usually helpful to describe the value that was incorrect.\nThat way any assertion failure message will be more helpful.\n\n\nIn order to do this, Strikt provides an overridden version of \nfail()\n that accepts a message string and the actual value found.\nThe message string should contain a format placeholder for the value.\n\n\nfun Assertion\nLocalDate\n.isStTibsDay(): Assertion\nLocalDate\n =\n  assert(\nis St. Tib's Day\n) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -\n pass()\n      else               -\n fail(\nin fact it is %s\n, subject)\n    }\n  }\n\n\n\n\nNow if the assertion fails there is a little more detail.\n\n\n\u25bc Expect that 2018-05-01\n  \u2718 is St. Tib's Day\n\n\n\n\nAssertions based on boolean conditions\n\n\nFor the very simplest assertion functions, instead of using \nassert\n and calling \npass\n or \nfail\n, you can use \npassesIf\n with a lambda whose receiver is the assertion subject that returns a boolean.\n\n\nWe can re-implement the example above like this:\n\n\nfun Assertion\nLocalDate\n.isStTibsDay(): Assertion\nLocalDate\n =\n  passesIf(\nis St. Tib's Day\n) { \n    MonthDay.from(this) == MonthDay.of(2, 29)\n  }\n\n\n\n\nYou should not use this form when you want to provide a meaningful description of the actual value but for simple assertions it's slightly less verbose.\n\n\nComposed assertions\n\n\nFor more complex assertion implementations you can \"nest\" sub-assertions inside your overall assertion.\nComposed assertions' results are reported under the overall result which can be very useful for providing detailed diagnostic information in case of a failure.\n\n\nComposed assertions are useful for things like:\n\n\n\n\napplying assertions to multiple properties of an object, for example for a field-by-field comparison.\n\n\napplying assertions to all elements of a collection or entries in a map, reporting on individual elements.\n\n\n\n\nImagine we're creating an assertion function that tests fails if any element of a collection is \nnull\n.\n\n\nfun \nT: Iterable\nE?\n, E\n Assertion\nT\n.containsNoNullElements(): Assertion\nT\n =\n  assert(\ndoes not contain any null elements\n) {\n    compose {\n      subject.forEach {\n        expect(it).isNotNull()\n      }\n    } results {\n      if (allPassed) pass() else fail()\n    }\n  }\n\n\n\n\nBreaking this down:\n\n\n\n\nWe declare the overall assertion function applies to an \nIterable\n of a nullable element type \nE\n.\n\n\nWe use the \nassert\n method to create the overall assertion with a description as usual.\n\n\nInside the block passed to \ncompose\n we make an assertion about each element of the subject.\n\n\nInside the results block we pass or fail the overall assertion depending on whether the nested assertions all passed.\n\n\n\n\nThe receiver of the block passed to \nresult\n has the properties \nallFailed\n, \nanyFailed\n, \nallPassed\n and \nanyPassed\n along with \npass()\n and \nfail()\n functions similar to those used in simple assertions.\n\n\nIf the assertion failed we'll see something like this:\n\n\n\u25bc Expect that [catflap, null, rubberplant, marzipan] \n  \u2718 does not contain any null elements: \n    \u25bc \ncatflap\n \n      \u2714 is not null\n    \u25bc null \n      \u2718 is not null  \n    \u25bc \nrubberplant\n \n      \u2714 is not null\n    \u25bc \nmarzipan\n \n      \u2714 is not null\n\n\n\n\nAs well as the overall assertion failure message we get a detailed breakdown allowing us to easily find exactly where the problem is.\n\n\nSeveral assertion functions in Strikt's standard assertions library use nested assertions.\nFor example, \nAssertion\nIterable\nE\n.all\n applies assertions to each element of an \nIterable\n then passes the overall assertion if (and only if) all those nested assertions passed (\nallPassed\n).\nOn the other hand \nAssertion\nIterable\nE\n.any\n applies assertions to the elements of an \nIterable\n but will pass the overall assertion if at least one of those nested assertions passed (\nanyPassed\n).\nThe \nAssertion\nIterable\nE\n.none\n assertion passes only if \nallFailed\n is true for its nested assertions!", 
            "title": "Custom Assertions"
        }, 
        {
            "location": "/user-guide/custom-assertions/#custom-assertions", 
            "text": "One of the aims of Strikt is that implementing your own assertions is  really, really  easy.\nAssertion functions are  extension functions  on the interface  Assertion T .", 
            "title": "Custom Assertions"
        }, 
        {
            "location": "/user-guide/custom-assertions/#simple-assertions", 
            "text": "Simple assertions produce a single message on failure.\nThey call  assert  passing a lambda with the assertion logic that calls  pass()  or  fail() .  The standard assertions  isNull ,  isEqualTo ,  isA T  and many others are simple assertions implemented just like this.  Let's imagine we're implementing an assertion function for  java.time.LocalDate  that tests if the represented date is a leap day.  fun Assertion LocalDate .isStTibsDay(): Assertion LocalDate  =\n  assert( is St. Tib's Day ) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -  pass()\n      else               -  fail()\n    }\n  }  Breaking this down:    We declare the assertion function applies only to  Assertion LocalDate .  Note that the function also returns  Assertion LocalDate  so we can include this assertion as part of a chain.  We call  assert  passing a description of the assertion and a lambda with the assertion logic.  If  subject  is the value we want we call  pass()  otherwise we call  fail()   If this assertion fails it will produce a message like:  \u25bc Expect that 2018-05-01\n  \u2718 is St. Tib's Day", 
            "title": "Simple assertions"
        }, 
        {
            "location": "/user-guide/custom-assertions/#where-do-subject-pass-and-fail-come-from", 
            "text": "The method  assert  accepts a description for the assertion being made and a lambda function  AssertionContext T .() -  Unit .\nThat  AssertionContext T  receiver provides the lambda everything it needs to access the  subject  of the assertion and report the result via the  pass()  or  fail()  method.", 
            "title": "Where do subject, pass() and fail() come from?"
        }, 
        {
            "location": "/user-guide/custom-assertions/#describing-the-actual-value", 
            "text": "For assertions that perform a comparison between actual and expected values it is usually helpful to describe the value that was incorrect.\nThat way any assertion failure message will be more helpful.  In order to do this, Strikt provides an overridden version of  fail()  that accepts a message string and the actual value found.\nThe message string should contain a format placeholder for the value.  fun Assertion LocalDate .isStTibsDay(): Assertion LocalDate  =\n  assert( is St. Tib's Day ) { \n    when (MonthDay.from(subject)) {\n      MonthDay.of(2, 29) -  pass()\n      else               -  fail( in fact it is %s , subject)\n    }\n  }  Now if the assertion fails there is a little more detail.  \u25bc Expect that 2018-05-01\n  \u2718 is St. Tib's Day", 
            "title": "Describing the \"actual\" value"
        }, 
        {
            "location": "/user-guide/custom-assertions/#assertions-based-on-boolean-conditions", 
            "text": "For the very simplest assertion functions, instead of using  assert  and calling  pass  or  fail , you can use  passesIf  with a lambda whose receiver is the assertion subject that returns a boolean.  We can re-implement the example above like this:  fun Assertion LocalDate .isStTibsDay(): Assertion LocalDate  =\n  passesIf( is St. Tib's Day ) { \n    MonthDay.from(this) == MonthDay.of(2, 29)\n  }  You should not use this form when you want to provide a meaningful description of the actual value but for simple assertions it's slightly less verbose.", 
            "title": "Assertions based on boolean conditions"
        }, 
        {
            "location": "/user-guide/custom-assertions/#composed-assertions", 
            "text": "For more complex assertion implementations you can \"nest\" sub-assertions inside your overall assertion.\nComposed assertions' results are reported under the overall result which can be very useful for providing detailed diagnostic information in case of a failure.  Composed assertions are useful for things like:   applying assertions to multiple properties of an object, for example for a field-by-field comparison.  applying assertions to all elements of a collection or entries in a map, reporting on individual elements.   Imagine we're creating an assertion function that tests fails if any element of a collection is  null .  fun  T: Iterable E? , E  Assertion T .containsNoNullElements(): Assertion T  =\n  assert( does not contain any null elements ) {\n    compose {\n      subject.forEach {\n        expect(it).isNotNull()\n      }\n    } results {\n      if (allPassed) pass() else fail()\n    }\n  }  Breaking this down:   We declare the overall assertion function applies to an  Iterable  of a nullable element type  E .  We use the  assert  method to create the overall assertion with a description as usual.  Inside the block passed to  compose  we make an assertion about each element of the subject.  Inside the results block we pass or fail the overall assertion depending on whether the nested assertions all passed.   The receiver of the block passed to  result  has the properties  allFailed ,  anyFailed ,  allPassed  and  anyPassed  along with  pass()  and  fail()  functions similar to those used in simple assertions.  If the assertion failed we'll see something like this:  \u25bc Expect that [catflap, null, rubberplant, marzipan] \n  \u2718 does not contain any null elements: \n    \u25bc  catflap  \n      \u2714 is not null\n    \u25bc null \n      \u2718 is not null  \n    \u25bc  rubberplant  \n      \u2714 is not null\n    \u25bc  marzipan  \n      \u2714 is not null  As well as the overall assertion failure message we get a detailed breakdown allowing us to easily find exactly where the problem is.  Several assertion functions in Strikt's standard assertions library use nested assertions.\nFor example,  Assertion Iterable E .all  applies assertions to each element of an  Iterable  then passes the overall assertion if (and only if) all those nested assertions passed ( allPassed ).\nOn the other hand  Assertion Iterable E .any  applies assertions to the elements of an  Iterable  but will pass the overall assertion if at least one of those nested assertions passed ( anyPassed ).\nThe  Assertion Iterable E .none  assertion passes only if  allFailed  is true for its nested assertions!", 
            "title": "Composed assertions"
        }, 
        {
            "location": "/about/", 
            "text": "About Strikt\n\n\nStrikt was written by \nRob Fletcher\n.\n\n\nLicense\n\n\nStrikt is licensed under the \nApache License v2.0\n.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about-strikt", 
            "text": "Strikt was written by  Rob Fletcher .", 
            "title": "About Strikt"
        }, 
        {
            "location": "/about/#license", 
            "text": "Strikt is licensed under the  Apache License v2.0 .", 
            "title": "License"
        }
    ]
}